#!/bin/bash
##################################################
# Usage: backup {list|dump [force]|restore DATE} #
# DATE: YY-MM-DD                                 #
# Must be run as root                            #
##################################################

if [ $(id -u) != '0' ]; then
	echo 'You need root privileges to run this script' 2>&1
	exit 1
fi

if [ -z "$BACKUP_DIR" ]; then
	BACKUP_DIR='<%=@backupDir%>'
fi

SCRIPT_NAME="$0"
ACTION="$1"
BACKUP_DATE="$2"
INSTALL_DIR=$(dirname $(readlink -f "$SCRIPT_NAME"))
MAX_BACKUPS=1
MAX_LOGS=1
EXIT_CODE=0

function showUsageAndExit {
	printf "Usage: backup {list|dump [force]|restore DATE}\nDATE: YY-MM-DD\n"
	exit 2
}

function toBackupType {
	SCRIPT_FILE=$1
	BACKUP_TYPE=${SCRIPT_FILE%.sh}
	echo ${BACKUP_TYPE#backup-}
}

function toBackupTaskId {
	SCRIPT_FILE=$1
	BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
	echo "$BACKUP_TYPE-$BACKUP_DATE"
}

function printStatusMessage {
			MSG="$1"
			STATE="$2"
			SPACER="                                                          "
			printf "%s%s%20s\n" "$MSG" "${SPACER:${#MSG}}" "$STATE"
}

function list {
	BYTE_COUNT=0
	for FILE in $(ls "$BACKUP_DIR"); do
		BYTE_COUNT=$(expr $BYTE_COUNT + $(stat -c %s "$BACKUP_DIR/$FILE"))
	done
        K_BYTE_COUNT=$(expr $BYTE_COUNT / 1024)
        M_BYTE_COUNT=$(expr $K_BYTE_COUNT / 1024)
        M_BYTE_COUNT=$(expr $M_BYTE_COUNT + 1)
        printStatusMessage "# Total size:" "~${M_BYTE_COUNT}M"
	ls "$BACKUP_DIR" | grep -Po '[\d]{2}-[\d]{2}-[\d]{2}' | uniq | sort -r | while read -r ARCHIVE_DATE; do
		echo "$ARCHIVE_DATE"
		for ARCHIVE in $(ls "$BACKUP_DIR" | grep -P "$ARCHIVE_DATE\.tar\.bz2$"); do
			ARCHIVE_SIZE=$(ls -lah "$BACKUP_DIR/$ARCHIVE" | awk '{print $5}')
			printStatusMessage " * ${ARCHIVE%-$ARCHIVE_DATE.tar.bz2}" "$ARCHIVE_SIZE"
		done
	done
}

function cleanDirectory {
	CLEAN_DIR="$1"
	MAX_COUNT=$2
	cd "$CLEAN_DIR"
	ls | grep -Po '[\d]{2}-[\d]{2}-[\d]{2}' | uniq | sort | head -n "-$MAX_COUNT" | while read -r ARCHIVE_DATE; do
		echo "  * remove $ARCHIVE_DATE"
		ls | grep $ARCHIVE_DATE | xargs rm
	done
}

function runBackupTask {
	SCRIPT_FILE="$1"
	BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
	BACKUP_TASK_ID=$(toBackupTaskId $SCRIPT_FILE)
	
	BACKUP_ARCHIVE="$BACKUP_DIR/$BACKUP_TASK_ID.tar.bz2"
	CUR_TMP_DIR="$TMP_DIR/$BACKUP_TASK_ID"

	if [ $ACTION = 'dump' ]; then
		if [ -f "$BACKUP_ARCHIVE" ]; then
			printf "WARNING: $BACKUP_ARCHIVE\n         already exists and will be overwritten\n"
		fi

		mkdir $CUR_TMP_DIR
	else
		if [ ! -f "$BACKUP_ARCHIVE" ]; then
			echo "failed: $BACKUP_ARCHIVE does not exist"
			return 1
		fi

		echo '* decompress backup'
		cd $TMP_DIR
		tar xvjf "$BACKUP_ARCHIVE"
		DECOMPRESSION_EXIT_CODE=$?

		if [ $DECOMPRESSION_EXIT_CODE != '0' ]; then
			echo "failed: Couldn't extract $BACKUP_ARCHIVE in $TMP_DIR"
			return 1
		fi
	fi

	bash "$INSTALL_DIR/tasks/$SCRIPT_FILE" $ACTION $CUR_TMP_DIR
	STATUS=$?

	if [ $STATUS = '0' ]; then
		if [ $ACTION = 'dump' ]; then
			echo '* compress backup'
			cd $TMP_DIR
			tar cvjf "$TMP_ARCHIVE_DIR/$BACKUP_TASK_ID.tar.bz2" $BACKUP_TASK_ID
			COMPRESSION_EXIT_CODE=$?

			if [ $COMPRESSION_EXIT_CODE != '0' ]; then
				echo "failed: Couldn't compress and save backup to $BACKUP_ARCHIVE"
				return 1
			fi
		fi

		echo 'done'
		return 0
	else
		echo 'failed'
		return 1
	fi
}

function runBackup {
	LOG_DIR="$INSTALL_DIR/log"
	LOG_FILE="$LOG_DIR/$ACTION-$BACKUP_DATE.log"
	TMP_DIR="/tmp/backup-$BACKUP_DATE"
	TMP_ARCHIVE_DIR="$TMP_DIR/backups"
	PATH="$PATH:$INSTALL_DIR/bin"

	if [ -d "$TMP_DIR" ]; then
		echo "failed: Temp directory $TMP_DIR is in use" 2>&1
		exit 4
	fi

	mkdir -p "$BACKUP_DIR"
	mkdir -p $TMP_ARCHIVE_DIR

	echo "$ACTION date $BACKUP_DATE:"

	# Run backup tasks parallel
	for SCRIPT_FILE in $(ls "$INSTALL_DIR/tasks" | grep -P '\.sh$'); do
		BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
		BACKUP_TASK_ID=$(toBackupTaskId $SCRIPT_FILE)
		PARTIAL_LOG_FILE="$LOG_DIR/$BACKUP_TASK_ID.log"
		echo "* $BACKUP_TYPE"
		printf '' > $PARTIAL_LOG_FILE

		runBackupTask "$SCRIPT_FILE" &>> "$PARTIAL_LOG_FILE" &
		declare "${BACKUP_TYPE}_PID=$!"
	done

	echo ''

	# Wait for tasks to terminate and collect exit codes
	for SCRIPT_FILE in $(ls "$INSTALL_DIR/tasks" | grep -P '\.sh$'); do
		BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
		PID_VAR=$(toBackupType $SCRIPT_FILE)'_PID'
		wait ${!PID_VAR}
		TASK_EXIT_CODE=$?

		if [ $TASK_EXIT_CODE != '0' ]; then
			echo "! $BACKUP_TYPE failed"
		        EXIT_CODE=3
		fi
	done

	# Concat task logs and write to single $LOG_FILE
	printf '' > $LOG_FILE
	for SCRIPT_FILE in $(ls "$INSTALL_DIR/tasks" | grep -P '\.sh$'); do
		BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
		BACKUP_TASK_ID=$(toBackupTaskId $SCRIPT_FILE)
		PARTIAL_LOG_FILE="$LOG_DIR/$BACKUP_TASK_ID.log"
		echo '===============================================================================' >> "$LOG_FILE"
		echo "  $ACTION $BACKUP_TYPE" >> "$LOG_FILE"
		echo '===============================================================================' >> "$LOG_FILE"
		cat "$PARTIAL_LOG_FILE" >> "$LOG_FILE"
		rm -rf "$PARTIAL_LOG_FILE"
	done

	echo '===============================================================================' >> "$LOG_FILE"

	if [ $EXIT_CODE = '0' ] && [ $ACTION = 'dump' ]; then
		# Move compressed backups to $BACKUP_DIR
		echo "* move compressed backups to $BACKUP_DIR" >> "$LOG_FILE"

		for ARCHIVE in $(ls "$TMP_ARCHIVE_DIR"); do
			echo "  * $ARCHIVE" >> "$LOG_FILE"
			mv "$TMP_ARCHIVE_DIR/$ARCHIVE" "$BACKUP_DIR/$ARCHIVE" &>> "$LOG_FILE" &&
			chmod 600 "$BACKUP_DIR/$ARCHIVE" &>> "$LOG_FILE"
			ARCHIVE_MV_EXIT_CODE=$?

			if [ $ARCHIVE_MV_EXIT_CODE != '0' ]; then
				EXIT_CODE=6
			fi
		done

		if [ $EXIT_CODE = '0' ]; then
			echo "* remove old backups" >> "$LOG_FILE"
			cleanDirectory "$BACKUP_DIR" $MAX_BACKUPS &>> "$LOG_FILE"
			echo "* remove old logs" >> "$LOG_FILE"
			cleanDirectory "$LOG_DIR" $MAX_LOGS &>> "$LOG_FILE"
		fi
	fi

	if [ $EXIT_CODE = '0' ]; then
		echo "finished successfully" >> "$LOG_FILE"
		echo "finished successfully (see $LOG_FILE)"
		
		if [ $ACTION = 'dump' ]; then
			echo "Run 'backup restore $BACKUP_DATE' to restore this backup"
		fi
	else
		echo "finished with error(s)" >> "$LOG_FILE"
		printf "\nfinished with error(s) (see $LOG_FILE)\n"
	fi

	rm -rf $TMP_DIR
}



case "$ACTION" in
	dump)
		BACKUP_DATE=$(date +'%y-%m-%d')
		FORCE_OVERWRITE="$2"

		if [ ! -z "$FORCE_OVERWRITE" ] && [ "$FORCE_OVERWRITE" != 'force' ]; then
			showUsageAndExit
		fi

		if [ -d $BACKUP_DIR ]; then
			ls $BACKUP_DIR | grep -P $BACKUP_DATE'\.tar\.bz2$' >> /dev/null
			BACKUP_DATE_SEARCH_EXIT_CODE=$?

			if [ $BACKUP_DATE_SEARCH_EXIT_CODE = '0' ]; then
				if [ "$FORCE_OVERWRITE" = 'force' ]; then
					echo "WARNING: Backup date $BACKUP_DATE already exists and will be overwritten"
				else
					printf "failed: Backup date $BACKUP_DATE already exists. \nAdd 'force' argument to overwrite old backups\n" 2>&1
					exit 5
				fi
			fi
		fi

		runBackup
	;;
	restore)
		if [ -z "$BACKUP_DATE" ]; then
			showUsageAndExit
		fi

		runBackup
	;;
	list)
		list
	;;
	*)
		showUsageAndExit
	;;
esac

exit $EXIT_CODE
