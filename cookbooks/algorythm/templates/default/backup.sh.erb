#!/bin/bash
#####################################
# Usage: backup {dump|restore DATE} #
# Must be run as root               #
#####################################

if [ $(id -u) != '0' ]; then
	echo 'You need root privileges to run this script' 2>&1
	exit 1
fi

if [ -z "$BACKUP_DIR" ]; then
	BACKUP_DIR='<%=@backupDir%>'
fi

SCRIPT_NAME="$0"
ACTION="$1"

function showUsageAndExit {
	echo "Usage: $SCRIPT_NAME {dump|restore ID}"
	exit 2
}

case "$ACTION" in
	dump)
		ACTION_LABEL="Backing up"
		BACKUP_DATE=$(date +'%y-%m-%d_%H-%M')
	;;
	restore)
		ACTION_LABEL="Restoring"
		BACKUP_DATE="$2"

		if [ -z "$BACKUP_DATE" ]; then
			showUsageAndExit
		fi
	;;
	*)
		showUsageAndExit
	;;
esac

INSTALL_DIR=$(dirname $(readlink -f "$SCRIPT_NAME"))
LOG_DIR="$INSTALL_DIR/log"
PATH="$PATH:$INSTALL_DIR/bin"
BACKUP_ID="backup-$BACKUP_DATE"
LOG_FILE="$LOG_DIR/$BACKUP_ID.log"
TMP_DIR="/tmp/$BACKUP_ID"
SCRIPT_ERROR=false

if [ -d "$TMP_DIR" ] || [ -f "$LOG_FILE" ]; then
	echo "Temp directory $TMP_DIR is in use" 2>&1
	exit 4
fi

mkdir $TMP_DIR
mkdir -p $BACKUP_DIR

function toBackupType {
	SCRIPT_FILE=$1
	BACKUP_TYPE=${SCRIPT_FILE%.sh}
	echo ${BACKUP_TYPE#backup-}
}

function toBackupTaskId {
	SCRIPT_FILE=$1
	BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
	echo "$BACKUP_TYPE-$BACKUP_DATE"
}

function runBackupTask {
	SCRIPT_FILE="$1"
	BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
	BACKUP_TASK_ID=$(toBackupTaskId $SCRIPT_FILE)
	
	BACKUP_ARCHIVE="$BACKUP_DIR/$BACKUP_TASK_ID.tar.bz2"
	CUR_TMP_DIR="$TMP_DIR/$BACKUP_TASK_ID"

	if [ $ACTION = 'dump' ]; then
		if [ -f "$BACKUP_ARCHIVE" ]; then
			echo "failed: $BACKUP_ARCHIVE already exists"
			return 1
		fi

		mkdir $CUR_TMP_DIR
		chmod 777 $CUR_TMP_DIR
	else
		if [ ! -f "$BACKUP_ARCHIVE" ]; then
			echo "failed: $BACKUP_ARCHIVE does not exist"
			return 1
		fi

		cd $TMP_DIR
		tar xjf "$BACKUP_ARCHIVE"
		STATUS=$?

		if [ $STATUS != '0' ]; then
			echo "failed: Couldn't extract $BACKUP_ARCHIVE in $TMP_DIR"
			return 1
		fi
	fi

	sh "$INSTALL_DIR/tasks/$SCRIPT_FILE" $ACTION $CUR_TMP_DIR
	STATUS=$?

	if [ $STATUS = '0' ]; then
		if [ $ACTION = 'dump' ]; then
			cd $TMP_DIR
			tar cjf "$BACKUP_ARCHIVE" $BACKUP_TASK_ID
			STATUS=$?

			if [ $STATUS = '0' ]; then
				chmod 600 $BACKUP_ARCHIVE
			else
				echo "failed: Couldn't compress and save backup to $BACKUP_ARCHIVE"
				return 1
			fi
		fi

		echo "done"
		return 0
	else
		echo "failed"
		return 1
	fi
}



echo "$ACTION_LABEL $BACKUP_DATE in $BACKUP_DIR:"

# Run backup tasks parallel
for SCRIPT_FILE in $(ls "$INSTALL_DIR/tasks" | grep -P "\.sh"); do
        BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
        BACKUP_TASK_ID=$(toBackupTaskId $SCRIPT_FILE)
        echo "  - $BACKUP_TYPE"

        runBackupTask "$SCRIPT_FILE" >> "$LOG_DIR/$BACKUP_TASK_ID.log" &
        declare "${BACKUP_TYPE}_PID=$!"

        rm -rf $TMP_DIR/$BACKUP_TASK_ID
done

# Wait for tasks to terminate and collect exit codes
for SCRIPT_FILE in $(ls "$INSTALL_DIR/tasks" | grep -P "\.sh"); do
        PID_VAR=$(toBackupType $SCRIPT_FILE)'_PID'
        wait ${!PID_VAR}
        TASK_EXIT_CODE=$?

        if [ $TASK_EXIT_CODE != '0' ]; then
                SCRIPT_ERROR=true
        fi
done

# Merge logs
for SCRIPT_FILE in $(ls "$INSTALL_DIR/tasks" | grep -P '\.sh'); do
	BACKUP_TYPE=$(toBackupType $SCRIPT_FILE)
	BACKUP_TASK_ID=$(toBackupTaskId $SCRIPT_FILE)
	echo '###' >> "$LOG_FILE"
	echo "# $ACTION_LABEL $BACKUP_TYPE ###" >> "$LOG_FILE"
	echo '###' >> "$LOG_FILE"
	cat "$LOG_DIR/$BACKUP_TASK_ID.log"    >> "$LOG_FILE"
	rm -rf "$LOG_DIR/$BACKUP_TASK_ID.log"
done

rm -rf $TMP_DIR


if $SCRIPT_ERROR; then
	echo "Finished with error(s)" >> "$LOG_FILE"
	echo "Finished with error(s) (see log file $LOG_FILE)"
	exit 3
else
	echo "Finished successfully"  >> "$LOG_FILE"
	echo "Finished successfully"
	echo "Run 'backup restore $BACKUP_DATE' to restore this backup"
fi
